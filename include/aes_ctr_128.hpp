// SPDX-FileCopyrightText: Steven Ward
// SPDX-License-Identifier: OSL-3.0

/// A PRNG that uses AES instructions
/**
* \file
* \author Steven Ward
*/

#pragma once

#if defined(__AES__)

#include "abstract_urbg_class.hpp"
#include "mm_cast.hpp"
#include "mm_equal.h"
#include "scaled-const.h"
#include "simd-array.hpp"

#include <cstdint>
#include <immintrin.h>
#include <random>

#if !defined(__SIZEOF_INT128__)
#error "__SIZEOF_INT128__ not defined"
#endif

// s[0] is the state/counter
// s[1] is the key
DEF_URBG_SUBCLASS(aes_ctr_128, arr_m128i<2>, __uint128_t)

/// prepare the initial state
void
aes_ctr_128::init()
{
    // the key must have more than 1 unique byte
    if (mm_all_equal_epi8(s[1]))
    {
        // most significant elem first
        const auto mask_key =
            _mm_set_epi64x(FLOOR_SCALED_FRAC_SQRT_7, FLOOR_SCALED_FRAC_SQRT_5);

        s[1] = _mm_xor_si128(s[1], mask_key);
    }
}

/// advance the state of the PRNG, and generate a pseudo-random value
/**
* Every odd integer is coprime with every power of 2.
* Therefore, \c inc shall be made odd.
*/
aes_ctr_128::result_type
aes_ctr_128::next()
{
    // must do at least 3 rounds of AES
    constexpr unsigned int Nr = 3;
    static_assert(Nr >= 3);

    /*
    * Criteria for integers of \c inc:
    *   1) Must be odd
    *   2) Must be unique
    *   3) Should have half the bits set
    *
    * Integers of \c inc were generated by the script `patterned_primes.py`.
    *
    * \sa https://en.wikipedia.org/wiki/Weyl_sequence#In_computing
    */

    // most significant elem first
    const __m128i inc = _mm_set_epi32(0x4a535aab, 0x55952d55, 0x6accb295, 0xad659529);

    __m128i dst = s[0];
    s[0] = _mm_add_epi32(s[0], inc);

    for (unsigned int r = 0; r < Nr; ++r)
    {
        dst = _mm_aesenc_si128(dst, s[1]);
    }

    return uint128_from_m128i(dst);
}

#else

#warning "__AES__ not defined"

#endif
