// SPDX-FileCopyrightText: Steven Ward
// SPDX-License-Identifier: OSL-3.0

/// A PRNG that uses AES instructions
/**
* \file
* \author Steven Ward
*/

#pragma once

#include "abstract_urbg_class.hpp"
#include "mm_cast.hpp"
#include "simd-array.hpp"
#include "simd-compress.h"

#include <immintrin.h>

#if !defined(__SIZEOF_INT128__)
#error "__SIZEOF_INT128__ not defined"
#endif

// s[0] is the first state/counter
// s[1] is the second state/counter
DEF_URBG_SUBCLASS(aes_compress_ctr2_128, arr_m128i<2>, __uint128_t)

/// prepare the initial state
void
aes_compress_ctr2_128::init()
{
}

/// advance the state of the PRNG, and generate a pseudo-random value
/**
* Every odd integer is coprime with every power of 2.
* Therefore, \c inc shall be made odd.
*/
aes_compress_ctr2_128::result_type
aes_compress_ctr2_128::next()
{
    /*
    * Criteria for integers of \c inc:
    *   1) Must be odd
    *   2) Must be unique
    *   3) Should have half the bits set
    *
    * Integers of \c inc were generated by the script `patterned_primes.py`.
    *
    * \sa https://en.wikipedia.org/wiki/Weyl_sequence#In_computing
    */
    const arr_m128i<2> inc{
        // most significant elem first
        _mm_set_epi32(0x4a535aab, 0x552d2ad3, 0x666a54cd, 0xa5a55a95),
        _mm_set_epi32(0x4d4b2b59, 0x59694b35, 0x95535a55, 0xad659529),
    };

    s[0] = _mm_add_epi32(s[0], inc[0]);
    s[1] = _mm_add_epi32(s[1], inc[1]);

    return uint128_from_m128i(compress_aesenc4_128(s[0], s[1]));
}
